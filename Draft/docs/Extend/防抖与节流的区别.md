# 防抖与节流的区别

## 引言

**节流 (Throttle)** 和 **防抖 (Debounce)** 是两种常见的性能优化技术，常用于限制函数的执行频率，尤其是在用户操作频繁触发事件时（如滚动、输入、窗口调整大小等），避免过多的无意义调用。它们有不同的工作原理和应用场景。

---

### 1. **节流 (Throttle)**

节流是限制函数在一定时间内只执行一次。即使事件被触发多次，函数也只有在设定的时间间隔内执行一次。节流的目的是降低函数的调用频率。

#### 工作原理:

- 每隔一定时间（例如每 300 毫秒），就会执行一次函数。即使事件在此间隔内多次触发，函数也只会执行一次。

#### 应用场景:

- 鼠标滚动、窗口大小调整、无限滚动等需要限制频繁调用的场景。

#### 节流的实现:

```javascript
function throttle(func, delay) {
  let lastTime = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastTime >= delay) {
      func.apply(this, args);
      lastTime = now;
    }
  };
}

// 使用示例
const logScroll = throttle(() => console.log("scrolling..."), 300);
window.addEventListener("scroll", logScroll);
```

### 2. **防抖 (Debounce)**

防抖是指函数在事件触发后，只有在事件停止触发一段时间后，才会执行。也就是说，如果事件在设定时间内被重复触发，只有最后一次触发后的时间间隔内函数才会执行。

#### 工作原理:

- 防抖的核心思想是: 只有当事件触发后，停止触发一定时间后，才会执行函数。比如输入框输入字符时，只有停止输入一段时间后，才会触发一次请求。

#### 应用场景:

- 搜索框输入建议、表单验证、窗口调整大小等需要等用户停止操作后才执行的场景。

#### 防抖的实现:

```javascript
function debounce(func, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer); // 清除上一次定时器
    timer = setTimeout(() => {
      func.apply(this, args);
    }, delay);
  };
}

// 使用示例
const search = debounce(() => console.log("Searching..."), 500);
document.getElementById("search-input").addEventListener("input", search);
```

### **总结区别**

| 特性     | 节流 (Throttle)                                  | 防抖 (Debounce)                                            |
| -------- | ------------------------------------------------ | ---------------------------------------------------------- |
| 执行方式 | 每隔一定时间执行一次，即使事件被多次触发         | 事件触发后，延迟一定时间才执行，若事件继续触发则重置定时器 |
| 触发条件 | 事件触发时，必须满足时间间隔才执行               | 事件触发后，延迟时间内未触发新事件才会执行                 |
| 适用场景 | 限制滚动、窗口大小调整、按钮点击等频繁触发的事件 | 输入框实时搜索、表单验证等需要等待用户停止操作的事件       |
| 类比     | 电梯等人: 最后一个人进来后才关门                 | 地铁发车: 按时发车，不等最后一个人                         |

### **总结应用场景**:

- **节流**: 适用于需要控制频繁事件（如滚动、窗口大小变化）执行的情况。
- **防抖**: 适用于需要等用户操作停止后的操作（如输入框自动完成、搜索、提交）情况。

通过这两种方法，可以有效地减少不必要的函数调用，提高性能并改善用户体验。
