# RegExp - Regular Expression

## 引言

`RegExp` 是 JavaScript 中的一个内置数据类型，用于基于模式进行字符串搜索。它通过丰富的语法特性允许执行复杂的字符串匹配操作。

注意 📢: 正则的应用不仅局限于 JavaScript 语言中，这里只是以前端学习为主去记录了。

---

### 字符类

- `[abc]`: 匹配单个字符，可以是 a、b 或 c 中的一个。
- `[^abc]`: 匹配单个字符，除了 a、b 或 c 之外的任意字符。
- `[a-z]`: 匹配任意小写字母
- `[A-Z]`: 匹配任意大写字母
- `[0-9]`: 匹配任意数字
- `[a-zA-Z0-9]`: 匹配任意字母或数字

### 元字符（边界匹配符）

- `.`: 匹配任意字符，除了换行符 \n
- `^`: 匹配字符串的开始位置
- `$`: 匹配字符串的结束位置
- `\b`: 匹配单词边界
- `\B`: 匹配非单词边界
- `\d`: 匹配数字字符，等价于 [0-9]
- `\D`: 匹配非数字字符，等价于 [^0-9]
- `\s`: 匹配空白字符，包括空格、制表符、换行符等
- `\S`: 匹配非空白字符
- `\w`: 匹配单词字符 (字母、数字、下划线)，等价于 [a-zA-Z0-9_]
- `\W`: 匹配非单词字符，等价于 [^a-zA-Z0-9_]
- `\t`: 匹配制表符
- `\n`: 匹配换行符
- `\r`: 匹配回车符
- `\Z`: 是一个特殊的断言符号，用于匹配字符串的结尾

注意 📢:
具体来说，`\Z` 匹配的是字符串的实际结束位置，不管是否存在换行符。
也可以理解为，`\Z` 匹配的是整个字符串的最后位置，而 `$` 匹配的是行的结束位置。
如果字符串以换行符结尾，`\Z` 只会匹配到最后一个字符，而 `$` 可能会匹配到换行符之前的位置。

### 量词 (重复匹配符 | 贪婪匹配符)

- `*`: 匹配前一个字符或子表达式零次或多次
- `+`: 匹配前一个字符或子表达式一次或多次
- `?`: 匹配前一个字符或子表达式零次或一次
- `{n}`: 匹配前一个字符或子表达式 n 次
- `{n,}`: 匹配前一个字符或子表达式至少 n 次
- `{n,m}`: 匹配前一个字符或子表达式至少 n 次，至多 m 次

### 分组和引用

- **匹配模式(pattern)**:

  匹配指定模式的字符串，使用圆括号 () 来创建分组。
  这可以用于将表达式的一部分进行捕获，或用于后续的引用和处理(通过编号或名称引用)。

- **捕获组**:

分组的内容会被捕获，并可以在替换操作中使用。捕获组的编号从 1 开始（$1、$2 等）

- **非捕获组**:

如果不需要捕获分组的内容，可以使用 (?:...) 来创建非捕获组。这只是用于分组，但不会保存匹配的内容。
\n: 后向引用，引用之前捕获的组内容。
例如，(\d)\1 匹配两个相同的数字，如 "11"、"22"。

### 特殊字符转义

- **\\**: 转义特殊字符，使为普通字符，失去特殊含义，如: \. 匹配字符 '.'

### 修饰符

i: 忽略大小写
g: 全局匹配，匹配所有符合条件的字符串，而不是只匹配第一个。
m: 多行匹配，匹配字符串中的每一行。

### 零宽断言 (Lookahead & Lookbehind)

    零宽断言是一种特殊的正则表达式匹配模式，它允许匹配一个位置，但不消费字符。

- `(?=pattern)`: 零宽正向先行断言，匹配 pattern 前面的位置，但不消费字符。 --- 正向肯定预查
- `(?!pattern)`: 零宽正向否定先行断言，匹配 pattern 前面的位置，但不消费字符。 --- 正向否定预查
- `(?<=pattern)`: 零宽反向先行断言，匹配 pattern 后面的位置，但不消费字符。 --- 反向肯定预查
- `(?<!pattern)`: 零宽反向否定先行断言，匹配 pattern 后面的位置，但不消费字符。 --- 反向否定预查

### 贪婪与懒惰

- **贪婪模式**: 量词会尽可能多的匹配字符，直到满足最大匹配条件。默认情况下，量词是贪婪模式。
- **非贪婪（懒惰）模式**: 量词会尽可能少地匹配字符，只满足最小的匹配条件。通过在量词后加上 ? 可以启用非贪婪模式。
  例如，a\*? 匹配尽可能少的 'a'。
